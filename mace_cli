#!/usr/bin/env python3
"""
MACE - Mendoza Automated CRYSTAL Engine
=======================================

Main entry point for the MACE workflow management system.

This script provides a unified interface to all MACE functionality,
including workflow planning, execution, monitoring, and analysis.

Developed by: Marcus Djokic
Contributors: Daniel Maldonado Lopez, Brandon Lewis, William Comaskey
Advisor: Prof. Jose Luis Mendoza-Cortes
Institution: Michigan State University, Mendoza Group
"""

import sys
import os
import argparse
from pathlib import Path

# Version information
__version__ = "1.0.0"

# Add MACE package to Python path
MACE_DIR = Path(__file__).parent / "mace"
sys.path.insert(0, str(MACE_DIR))

# Import animation and credits
try:
    from utils.animation import animate_mace_assembly, loading_bar
    from utils.banner import get_credits, print_banner
    BANNER_AVAILABLE = True
except ImportError:
    BANNER_AVAILABLE = False

def show_banner():
    """Show the MACE animated banner and credits"""
    # Check environment variable in case we're called from a subprocess
    if os.environ.get('MACE_NO_BANNER', '').lower() in ('1', 'true', 'yes'):
        return
        
    if BANNER_AVAILABLE:
        print()
        animate_mace_assembly(__version__)
        loading_bar(1.0, "Initializing MACE Workflow System")
        print(get_credits())
    else:
        print("\nMACE - Mendoza Automated CRYSTAL Engine")
        print(f"Version {__version__}")
        print("=" * 40)

def show_action_specific_help(command, action):
    """Show help for a specific action of any command"""
    
    # Delegate to command-specific help functions
    if command == 'database':
        show_database_action_help(action)
    elif command == 'monitor':
        show_monitor_action_help(action)
    elif command == 'engine':
        show_engine_action_help(action)
    elif command == 'workflow':
        show_workflow_action_help(action)
    elif command == 'recover':
        show_recover_action_help(action)
    else:
        print(f"\nNo action-specific help available for command: {command}")
        print(f"Try: mace {command} --help")

def show_database_action_help(action):
    """Show help for a specific database action"""
    action_help = {
        'stats': """
Usage: mace database --action stats

Show database statistics including material counts, calculation types, and status distribution.

No additional options required.

Example:
  mace database --action stats
""",
        'query': """
Usage: mace database --action query [options]

Search and list materials with optional property filters.

Options:
  --material-id ID      Show specific material details
  --filter "EXPR"       Filter by property values (can use multiple)
  --logic AND|OR        Logic for combining filters (default: AND)

Filter Examples:
  --filter "band_gap > 3.0"
  --filter "space_group IN (225, 227, 229)"
  --filter "(band_gap > 3 AND space_group = 227) OR formula LIKE 'C%'"

Examples:
  mace database --action query
  mace database --action query --material-id 1_dia
  mace database --action query --filter "band_gap > 3.0" --filter "space_group == 227"
""",
        'properties': """
Usage: mace database --action properties [options]

Display material properties and statistics.

Options:
  --material-id ID      Show properties for specific material
  --category NAME       Filter by category (electronic, structural, etc.)
  --from-calc TYPE      Show only properties from calculation type (OPT, SP, etc.)
  --compact             Compact display format
  --json                Show full JSON data including distributions
  --units UNIT_MAP      Convert units (e.g., "band_gap:eV,total_energy:kcal/mol")
  --all-units           Show all available units for properties

Examples:
  mace database --action properties
  mace database --action properties --material-id 1_dia
  mace database --action properties --category electronic --compact
  mace database --action properties --material-id 1_dia --from-calc OPT
  mace database --action properties --units "band_gap:eV,total_energy:eV"
  mace database --action properties --all-units
""",
        'export': """
Usage: mace database --action export [options]

Export data to various formats.

Options:
  --format FORMAT       Output format: csv, json, excel, latex, html (default: csv)
  --output FILE         Output file path (auto-generated if not specified)
  --filter "EXPR"       Apply filters before export
  --logic AND|OR        Filter logic (default: AND)
  --include-property X  Include specific property (repeat for multiple)
  --include-structures  Include structure data in export
  --properties-only     Export properties table instead of materials

Examples:
  mace database --action export --format excel --output results.xlsx
  mace database --action export --format json --filter "band_gap > 3"
  mace database --action export --properties-only --format csv
  mace database --action export --format latex --include-property band_gap --include-property total_energy
""",
        'compare': """
Usage: mace database --action compare --materials LIST [options]

Compare properties across multiple materials.

Options:
  --materials LIST      Comma-separated material IDs (required)
  --properties LIST     Specific properties to compare (optional)
  --output-format FMT   Output format: table, json, dict (default: table)

Examples:
  mace database --action compare --materials "1_dia,2_dia2,3_dia3"
  mace database --action compare --materials "1_dia,2_dia2" --properties "band_gap,total_energy"
  mace database --action compare --materials "mat1,mat2,mat3" --output-format json
""",
        'missing': """
Usage: mace database --action missing [options]

Analyze missing properties and suggest calculations to run.

Options:
  --material-ids LIST   Specific materials to analyze (comma-separated)
  --target-properties   Properties to check for (comma-separated)
  --detail-level LVL    Report detail: summary, detailed, full (default: summary)
  --output-format FMT   Output format: report, json, dict (default: report)

Examples:
  mace database --action missing
  mace database --action missing --material-ids "1_dia,2_dia2"
  mace database --action missing --detail-level full
  mace database --action missing --target-properties "band_gap,fermi_energy" --output-format json
""",
        'correlate': """
Usage: mace database --action correlate [options]

Calculate correlations between properties.

Options:
  --properties PAIRS    Property pairs like "prop1,prop2;prop3,prop4"
  --min-samples N       Minimum samples required (default: 3)
  --output-format FMT   Output format: report, json, dict (default: report)
  --top-n N             Number of top correlations to show (default: 20)

Examples:
  mace database --action correlate
  mace database --action correlate --properties "band_gap,total_energy;density,band_gap"
  mace database --action correlate --min-samples 5 --top-n 50
""",
        'distribution': """
Usage: mace database --action distribution [options]

Analyze property distributions and generate histograms.

Options:
  --properties LIST     Comma-separated properties to analyze
  --bins N              Number of histogram bins (default: 10)
  --output-format FMT   Output format: report, json, dict (default: report)
  --top-n N             Number of properties to show details for (default: 10)

Examples:
  mace database --action distribution
  mace database --action distribution --properties "band_gap,density,total_energy"
  mace database --action distribution --bins 20 --top-n 15
""",
        'workflow': """
Usage: mace database --action workflow [options]

Track workflow progress for materials.

Options:
  --material-ids LIST   Comma-separated material IDs (default: all)
  --workflow NAME       Predefined workflow: basic_opt, opt_sp, full_electronic, 
                        transport_analysis, charge_analysis, combined_analysis, complete
  --sequence LIST       Custom sequence (e.g., "OPT,SP,BAND")
  --detailed            Show detailed per-material progress
  --output-format FMT   Output format: report, json, csv

Examples:
  mace database --action workflow                          # Track default workflow
  mace database --action workflow --workflow full_electronic --detailed
  mace database --action workflow --material-ids "1_dia,2_dia2" --workflow opt_sp
  mace database --action workflow --sequence "OPT,SP,TRANSPORT"
""",
        'validate': """
Usage: mace database --action validate [options]

Validate property values and check data integrity.

Options:
  --material-ids LIST   Comma-separated material IDs (default: all)
  --fix                 Automatically fix issues where possible
  --check-integrity     Also check database integrity
  --output-format FMT   Output format: report, json

Validation checks:
  - Property type validation (float, int, string, etc.)
  - Range validation (min/max values)
  - Unit consistency
  - Cross-property validation (e.g., lattice parameters vs crystal system)
  - Database integrity (orphaned records, duplicates)

Examples:
  mace database --action validate                          # Validate all materials
  mace database --action validate --material-ids "1_dia,2_dia2"
  mace database --action validate --fix                    # Fix issues automatically
  mace database --action validate --check-integrity        # Full database check
""",
        'history': """
Usage: mace database --action history [options]

View and manage property change history.

Options:
  --material-id ID      Material ID (required for most operations)
  --property NAME       Specific property name
  --operation OP        Operation: view, snapshot, compare, rollback, recent
  --version N           Version number (for rollback/compare)
  --version2 N          Second version for comparison
  --limit N             Limit number of results (default: 100)
  --reason TEXT         Reason for change/rollback

Operations:
  view      View property history (default)
  snapshot  Create versioned snapshot of all properties
  compare   Compare two versions
  rollback  Rollback property to previous version
  recent    Show recent changes across all materials

Examples:
  mace database --action history --material-id 1_dia
  mace database --action history --material-id 1_dia --property band_gap
  mace database --action history --operation snapshot --material-id 1_dia
  mace database --action history --operation compare --material-id 1_dia --version 1 --version2 3
  mace database --action history --operation recent --limit 50
""",
        'interactive': """
Usage: mace database --action interactive

Launch interactive database explorer with command completion.

The interactive mode provides:
  - Tab completion for commands and material IDs
  - Property filtering and queries
  - Real-time unit conversion
  - Material comparison
  - Export capabilities
  - Command history

Interactive commands:
  select        Select material for exploration
  list          List materials
  search        Search by ID or formula
  filter        Add property filters
  query         Execute filtered query
  props         Show material properties
  compare       Compare materials
  export        Export results
  help          Show all commands

Example:
  mace database --action interactive
  mace-db> select 1_dia
  mace-db [1_dia]> props
  mace-db [1_dia]> filter band_gap > 3.0
  mace-db [1_dia]> query
""",
        'aggregate': """
Usage: mace database --action aggregate [options]

Aggregate properties by material groups.

Options:
  --group-by TYPE       Grouping criterion (required)
  --properties LIST     Comma-separated properties to aggregate (required)
  --aggregation FUNC    Aggregation function: mean, median, min, max, sum, count, stdev
  --filter "EXPR"       Filter materials before grouping
  --detailed            Show detailed group information
  --output-format FMT   Output format: report, json

Grouping options:
  space_group          Group by space group number
  crystal_system       Group by crystal system
  formula_prefix       Group by first element in formula
  conductivity_type    Group by conductivity type
  band_gap_range       Group by band gap ranges
  energy_range         Group by total energy ranges
  atoms_range          Group by number of atoms

Examples:
  mace database --action aggregate --group-by crystal_system --properties "band_gap,density"
  mace database --action aggregate --group-by space_group --properties "total_energy" --aggregation min
  mace database --action aggregate --group-by band_gap_range --properties "density,bulk_modulus" --detailed
  mace database --action aggregate --group-by formula_prefix --properties "band_gap" --filter "space_group == 227"
"""
    }
    
    if action in action_help:
        print(action_help[action])
    else:
        print(f"No specific help available for action: {action}")
        print(f"Available actions: {', '.join(sorted(action_help.keys()))}")

def show_monitor_action_help(action):
    """Show help for a specific monitor action"""
    action_help = {
        'dashboard': """
Usage: mace monitor --action dashboard [options]

Show real-time monitoring dashboard for all calculations.

Options:
  --interval SECONDS    Update interval (default: 30)
  --max-materials N     Limit display to N materials (default: unlimited)
  
Dashboard shows:
  - Active calculations with progress
  - Recently completed jobs
  - Error statistics
  - Resource utilization
  - Database health metrics
""",
        'stats': """
Usage: mace monitor --action stats

Show database and calculation statistics.

Displays:
  - Total materials and calculations
  - Calculation type distribution
  - Success/failure rates
  - Average runtimes
  - Property extraction coverage
""",
        'health': """
Usage: mace monitor --action health

Check database health and integrity.

Performs:
  - Database connection tests
  - Schema validation
  - Index optimization
  - Storage usage analysis
  - Orphaned record detection
"""
    }
    
    if action in action_help:
        print(action_help[action])
    else:
        print(f"No specific help available for action: {action}")
        print(f"Available actions: {', '.join(sorted(action_help.keys()))}")

def show_engine_action_help(action):
    """Show help for a specific engine action"""
    action_help = {
        'status': """
Usage: mace engine --action status [options]

Show workflow status for materials.

Options:
  --material-id ID      Show status for specific material
  --pending-only        Show only materials with pending workflows
  
Shows:
  - Current calculation status
  - Next planned steps
  - Workflow completion percentage
  - Error states
""",
        'process': """
Usage: mace engine --action process [options]

Process pending workflows and submit next calculations.

Options:
  --material-id ID      Process specific material only
  --dry-run             Show what would be done without executing
  --max-submit N        Maximum jobs to submit (default: 10)
  
Workflow progression:
  OPT → SP → BAND/DOSS/TRANSPORT/CHARGE+POTENTIAL
""",
        'workflow': """
Usage: mace engine --action workflow [options]

Show or modify workflow templates.

Options:
  --list                List available workflow templates
  --show TEMPLATE       Show details of a specific template
  --create NAME         Create new workflow template
  
Templates define calculation sequences and resource requirements.
"""
    }
    
    if action in action_help:
        print(action_help[action])
    else:
        print(f"No specific help available for action: {action}")
        print(f"Available actions: {', '.join(sorted(action_help.keys()))}")

def show_workflow_action_help(action):
    """Show help for a specific workflow action"""
    action_help = {
        'plan': """
Usage: mace workflow --action plan [options]

Plan a new workflow interactively or from configuration.

Options:
  --config FILE         Load workflow from JSON configuration
  --template NAME       Use predefined workflow template
  --output FILE         Save plan to file (default: auto-generated)
  
Interactive planning includes:
  - Input file selection (CIF/D12)
  - Calculation sequence design
  - Resource allocation
  - Dependency configuration
""",
        'execute': """
Usage: mace workflow --action execute [options]

Execute a saved workflow plan.

Options:
  --plan FILE           Workflow plan JSON file to execute
  --resume              Resume interrupted workflow
  --skip-validation     Skip input file validation
  
Execution includes:
  - File conversion (CIF → D12)
  - Job submission
  - Progress tracking
  - Error handling
""",
        'status': """
Usage: mace workflow --action status [options]

Check status of running workflows.

Options:
  --workflow-id ID      Specific workflow to check
  --active-only         Show only active workflows
  --detailed            Show step-by-step progress
  
Status information:
  - Overall progress percentage
  - Current step execution
  - Completed/failed/pending counts
  - Resource utilization
""",
        'templates': """
Usage: mace workflow --action templates

List available workflow templates.

Templates include:
  - basic_opt: Geometry optimization only
  - opt_sp: OPT → SP
  - full_electronic: OPT → SP → BAND → DOSS
  - transport_analysis: OPT → SP → TRANSPORT
  - complete: OPT → SP → BAND → DOSS → FREQ
  
Use --template with plan action to use a template.
"""
    }
    
    # Handle both explicit action and default modes
    if action == 'interactive':
        action = 'plan'
    elif action == 'quick-start':
        action = 'execute'
        
    if action in action_help:
        print(action_help[action])
    else:
        print(f"No specific help available for action: {action}")
        print(f"Available actions: {', '.join(sorted(action_help.keys()))}")
        print("Also: --interactive (interactive planning), --quick-start (quick execution)")

def show_recover_action_help(action):
    """Show help for a specific recover action"""
    action_help = {
        'recover': """
Usage: mace recover --action recover [options]

Detect and fix errors in failed calculations.

Options:
  --max-recoveries N    Maximum recovery attempts per material (default: 3)
  --error-type TYPE     Focus on specific error type
  --material-id ID      Recover specific material only
  
Recoverable errors:
  - SHRINK factor issues
  - Memory allocation failures
  - SCF convergence problems
  - Basis set issues
""",
        'stats': """
Usage: mace recover --action stats

Show error recovery statistics.

Displays:
  - Error type distribution
  - Recovery success rates
  - Most common failures
  - Materials requiring manual intervention
""",
        'config': """
Usage: mace recover --action config [options]

Manage error recovery configuration.

Options:
  --show                Display current configuration
  --edit                Open configuration in editor
  --validate            Check configuration validity
  
Configuration includes:
  - Error detection patterns
  - Fix strategies
  - Retry policies
  - Resource adjustments
"""
    }
    
    if action in action_help:
        print(action_help[action])
    else:
        print(f"No specific help available for action: {action}")
        print(f"Available actions: {', '.join(sorted(action_help.keys()))}")

def show_command_help(command):
    """Show help for a specific command"""
    help_text = {
        'workflow': """
Usage: mace workflow [options]

Run the MACE workflow planning and execution system.

Options:
  --interactive         Start interactive workflow planning
  --quick-start         Quick start with predefined templates
  --execute FILE        Execute a saved workflow plan
  --status              Check workflow status
  --show-templates      Display available workflow templates
  --cif-dir DIR         Directory containing CIF files (for quick start)
  --d12-dir DIR         Directory containing D12 files (for quick start)
  --workflow TYPE       Workflow template: basic_opt, opt_sp, full_electronic, 
                        double_opt, complete, transport_analysis, charge_analysis,
                        combined_analysis (default: full_electronic)
  --work-dir DIR        Working directory (default: current directory)
  --db-path PATH        Database path (default: materials.db)
  --max-jobs N          Maximum concurrent jobs (default: 200)

Examples:
  mace workflow --interactive
  mace workflow --quick-start --cif-dir ./cifs --workflow full_electronic
  mace workflow --execute workflow_plan_20250618_145837.json
  mace workflow --status
  mace workflow --show-templates

For action-specific options, use: mace workflow --action <ACTION> --help
""",
        'submit': """
Usage: mace submit <file_or_directory>

Submit CRYSTAL calculations to the queue.

Arguments:
  file_or_directory     D12/D3 file(s) or directory to submit

Examples:
  mace submit calculation.d12
  mace submit property.d3
  mace submit my_calculations/

Note: This command submits files using the appropriate submission script
(submitcrystal23.sh for D12 files, submit_prop.sh for D3 files).
For directories with mixed file types, you'll be prompted to choose.
Additional options like --max-jobs are not implemented in this wrapper.
""",
        'monitor': """
Usage: mace monitor [options]

Monitor running calculations and view system status.

Options:
  --dashboard           Launch real-time monitoring dashboard (default)
  --status              Show quick status summary
  --summary             Show minimal status (materials and total calculations only)
  --detailed            Show detailed status with calculation types and recent activity
  --material-id ID      Show status for specific material
  --interval N          Dashboard update interval in seconds (default: 30)

Examples:
  mace monitor                    # Real-time dashboard
  mace monitor --status           # Quick status check
  mace monitor --status --detailed # Detailed status with recent activity
  mace monitor --status --summary  # Minimal summary only

For action-specific options, use: mace monitor --action <ACTION> --help
""",
        'analyze': """
Usage: mace analyze --extract-properties <directory> [options]

Extract properties from CRYSTAL output files.

Options:
  --extract-properties DIR    Directory containing output files (required)
  --material-id ID           Filter by material ID or override material ID
  --calc-type TYPE           Filter by calculation type (OPT, SP, FREQ, BAND, DOSS)
  --filter-material ID       Only extract properties for specific material ID
  --filter-type TYPE         Only extract properties from specific calculation type
  --output-file FILE         Process a single output file instead of directory
  --db-path PATH            Path to materials database (default: materials.db)

Examples:
  mace analyze --extract-properties .
  mace analyze --extract-properties outputs/
  mace analyze --extract-properties . --material-id diamond
  mace analyze --extract-properties . --calc-type OPT
  mace analyze --extract-properties outputs/ --filter-material 1_dia --filter-type SP
  mace analyze --extract-properties --output-file single_calc.out

Note: This command extracts properties and stores them in the materials database.
Filters help process only specific materials or calculation types.
""",
        'convert': """
Usage: mace convert <cif_files> [options]

Convert CIF files to CRYSTAL D12 input format.
Runs NewCifToD12.py with all its options.

Examples:
  mace convert structure.cif
  mace convert *.cif
  mace convert structures/ --functional B3LYP --basis POB-TZVP

For full options, the command will show NewCifToD12.py help when run without arguments.
""",
        'opt2d12': """
Usage: mace opt2d12 <output_file> [options]

Generate D12 input files from optimized CRYSTAL output.
Runs CRYSTALOptToD12.py with all its options.

Examples:
  mace opt2d12 optimized.out
  mace opt2d12 calculation.out --sp
  mace opt2d12 calculation.out --freq
  mace opt2d12 calculation.out --both

For full options, the command will show CRYSTALOptToD12.py help when run without arguments.
""",
        'opt2d3': """
Usage: mace opt2d3 <output_file> --calc-type TYPE [options]

Generate D3 property input files from CRYSTAL output.
Runs CRYSTALOptToD3.py with all its options.

Examples:
  mace opt2d3 optimized.out --calc-type BAND
  mace opt2d3 optimized.out --calc-type DOSS
  mace opt2d3 optimized.out --calc-type ALL --mode advanced

For full options, the command will show CRYSTALOptToD3.py help when run without arguments.
""",
        'manager': """
Usage: mace manager [options]

Enhanced CRYSTAL Queue Manager with material tracking and workflow automation.

Options:
  --status              Show current queue status
  --d12-dir DIR         Directory with D12 files (default: current directory)
  --max-jobs N          Maximum concurrent jobs (default: 250)
  --reserve N           Reserved job slots (default: 30)
  --callback-mode MODE  Callback mode for completion handling
  --dry-run             Show what would be submitted without actually submitting

Examples:
  mace manager --status                              # Check queue status
  mace manager --d12-dir /path/to/calculations      # Run queue manager
  mace manager --max-jobs 200 --reserve 20          # Custom job limits
  mace manager --callback-mode completion            # Run in callback mode

Note: This runs the Enhanced Queue Manager (queue/manager.py) which requires SLURM.
""",
        'queue': """
Usage: mace queue [options]

Deprecated: Use 'mace manager' instead.
This command will be removed in a future version.
""",
        'recover': """
Usage: mace recover [options]

Automated error recovery for failed CRYSTAL calculations.

Options:
  --action ACTION       Action to perform: recover, stats, config (default: recover)
  --max-recoveries N    Maximum number of recoveries to attempt (default: 10)
  --config FILE         Path to recovery configuration file
  --create-config       Create default recovery configuration

Examples:
  mace recover
  mace recover --action stats
  mace recover --max-recoveries 5
  mace recover --create-config

For action-specific options, use: mace recover --action <ACTION> --help
""",
        'database': """
Usage: mace database [options]

Database management and queries for material tracking.

ACTIONS:
  stats        Show database statistics (default)
  query        Search and list materials with property filters
  properties   Display material properties and statistics
  export       Export data to CSV/JSON/Excel/LaTeX/HTML formats
  compare      Compare properties across multiple materials
  missing      Analyze missing properties and suggest calculations
  correlate    Calculate correlations between properties
  distribution Analyze property distributions and histograms
  workflow     Track multi-step workflow progress
  validate     Validate property values and data integrity
  history      View property change history and versioning
  interactive  Launch interactive database explorer
  aggregate    Aggregate properties by material groups

OPTIONS:
  --action ACTION       Action to perform (default: stats)
  --material-id ID      Specific material ID
  --filter "EXPR"       Filter by property (query/export)
  --logic AND|OR        Filter logic (default: AND)
  --format FORMAT       Export format (export only)
  --output FILE         Output file path (export only)
  --materials LIST      Comma-separated IDs (compare only)
  --material-ids LIST   Comma-separated IDs (missing only)
  
Options marked with specific actions in parentheses only work with those actions.

FILTER SYNTAX:
  Basic:     --filter "band_gap > 3.0" --filter "space_group == 227"
  Advanced:  --filter "(band_gap > 3 AND space_group = 227) OR formula LIKE 'C%'"
  
  Operators: >, <, >=, <=, ==, !=, =, LIKE, NOT LIKE, IN, IS NULL/NOT NULL
  Examples:
    --filter "formula LIKE 'C%'"                   # Pattern matching
    --filter "space_group IN (225, 227, 229)"      # Value lists
    --filter "transport_seebeck IS NOT NULL"       # NULL checks

QUICK EXAMPLES:
  mace database                                      # Show statistics
  mace database --action query --filter "band_gap > 3.0"
  mace database --action properties --material-id 1_dia --category electronic
  mace database --action export --format excel --output results.xlsx
  mace database --action compare --materials "1_dia,2_dia2,3_dia3"
  mace database --action missing --detail-level full
  mace database --action correlate                   # All property correlations
  mace database --action correlate --properties "band_gap,total_energy"
  mace database --action distribution               # Property distributions
  mace database --action distribution --properties "band_gap,density" --bins 20
  mace database --action workflow                    # Track workflow progress
  mace database --action workflow --workflow full_electronic --detailed
  mace database --action validate                    # Validate all materials
  mace database --action validate --fix --check-integrity
  mace database --action history --material-id 1_dia # View property history
  mace database --action history --operation recent  # Recent changes
""",
        'engine': """
Usage: mace engine [options]

Workflow automation engine for managing calculation progressions.

Options:
  --action ACTION       Action: status, process, workflow (default: status)
  --material-id ID      Material ID for status checking
  --db PATH             Path to materials database (default: materials.db)
  --work-dir DIR        Base working directory (default: current directory)

Examples:
  mace engine                                    # Show workflow status
  mace engine --action process                   # Process pending workflows
  mace engine --action status --material-id diamond
  mace engine --action workflow                  # Show workflow templates

For action-specific options, use: mace engine --action <ACTION> --help

Note: The --dry-run option shown in some docs is not implemented.
"""
    }
    
    if command in help_text:
        print(help_text[command])
    else:
        print(f"No help available for command: {command}")

def main():
    """Main entry point with proper argument parsing"""
    # Save original sys.argv before any modifications
    original_argv = sys.argv[:]
    
    # Check for action-specific help before argparse for any command
    if len(sys.argv) >= 5 and sys.argv[2] == '--action' and sys.argv[4] == '--help':
        command = sys.argv[1]
        action = sys.argv[3]
        show_action_specific_help(command, action)
        return
    
    # Special handling for commands that should pass through directly
    passthrough_commands = ['convert', 'opt2d12', 'opt2d3']
    
    # Handle --no-banner if it's the first argument
    no_banner_first = False
    if len(sys.argv) >= 2 and sys.argv[1] == '--no-banner':
        no_banner_first = True
        os.environ['MACE_NO_BANNER'] = '1'
        # Remove --no-banner and shift arguments
        sys.argv = [sys.argv[0]] + sys.argv[2:]
    
    # Check if we have a passthrough command
    if len(sys.argv) >= 2 and sys.argv[1] in passthrough_commands:
        # For passthrough commands, skip our argument parsing and go directly to the command
        command = sys.argv[1]
        
        # Check if --no-banner or --help is present
        suppress_banner = no_banner_first or '--no-banner' in sys.argv or '--help' in sys.argv or '-h' in sys.argv
        
        # Set --no-banner if needed
        if '--no-banner' in sys.argv:
            os.environ['MACE_NO_BANNER'] = '1'
            # Remove --no-banner from args passed to subcommand
            sys.argv = [arg for arg in sys.argv if arg != '--no-banner']
        
        # Show banner unless suppressed
        if not suppress_banner:
            show_banner()
        
        # Execute the command
        if command == 'convert':
            sys.path.insert(0, str(Path(__file__).parent / "Crystal_d12"))
            from NewCifToD12 import main as cif_main
            sys.argv = ['NewCifToD12.py'] + sys.argv[2:]
            cif_main()
        elif command == 'opt2d12':
            sys.path.insert(0, str(Path(__file__).parent / "Crystal_d12"))
            from CRYSTALOptToD12 import main as opt2d12_main
            sys.argv = ['CRYSTALOptToD12.py'] + sys.argv[2:]
            opt2d12_main()
        elif command == 'opt2d3':
            sys.path.insert(0, str(Path(__file__).parent / "Crystal_d3"))
            from CRYSTALOptToD3 import main as opt2d3_main
            sys.argv = ['CRYSTALOptToD3.py'] + sys.argv[2:]
            opt2d3_main()
        sys.exit(0)
    
    # Check if asking for help on a specific command (for non-passthrough commands)
    if len(sys.argv) >= 3 and sys.argv[2] == '--help' and sys.argv[1] in ['workflow', 'submit', 'monitor', 'analyze', 'status', 'queue', 'manager', 'recover', 'database', 'engine']:
        # Show command-specific help
        show_command_help(sys.argv[1])
        sys.exit(0)
    
    parser = argparse.ArgumentParser(
        description=f"MACE - Mendoza Automated CRYSTAL Engine (v{__version__})",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Commands:
  workflow    Interactive workflow planner - design and execute complex calculation sequences
  submit      Submit calculations to queue - handles both D12 and D3 files automatically
  monitor     System monitoring - real-time dashboard or quick status (--status, --detailed, --summary)
  analyze     Extract properties from outputs - band gaps, energies, convergence data
  convert     CIF to D12 conversion - supports all CRYSTAL basis sets and functionals
  opt2d12     Generate D12 from optimized output - create SP/FREQ inputs from OPT results
  opt2d3      Generate D3 property inputs - BAND, DOSS, TRANSPORT, CHARGE calculations
  manager     Enhanced Queue Manager - material tracking, workflow automation, SLURM integration
  recover     Error recovery - automated fixes for SHRINK, memory, and convergence issues
  database    Database queries - search materials, export results, view statistics
  engine      Workflow automation - manages OPT→SP→BAND progression automatically
  
Quick Start:
  mace workflow --interactive      # Plan new workflow
  mace monitor                     # Live dashboard
  mace monitor --status            # Quick status check
  
More Help:
  mace <command> --help           # Command details
"""
    )
    
    parser.add_argument('command', nargs='?', 
                       choices=['workflow', 'submit', 'monitor', 'analyze', 'convert', 'opt2d12', 'opt2d3', 
                               'status', 'queue', 'manager', 'recover', 'database', 'engine', 'credits', 'version'],
                       help='Command to run')
    parser.add_argument('args', nargs='*', help='Arguments for the command')
    parser.add_argument('--no-banner', action='store_true', help='Suppress ASCII art banner')
    parser.add_argument('--version', action='version', version=f'MACE v{__version__}')
    parser.add_argument('--credits', action='store_true', help='Show developer credits')
    
    # Parse known args to handle the main command
    args, remaining = parser.parse_known_args()
    
    # Handle --credits flag
    if args.credits:
        if BANNER_AVAILABLE and not args.no_banner:
            print_banner('banner')
            print(get_credits())
        elif BANNER_AVAILABLE:
            # Just show credits without banner
            print(get_credits())
        else:
            print("\nMACE Development Team:")
            print("Primary Developer: Marcus Djokic")
            print("Contributors: Daniel Maldonado Lopez, Brandon Lewis, William Comaskey")
            print("PI: Prof. Jose Luis Mendoza-Cortes")
        sys.exit(0)
    
    # Set environment variable for child processes
    if args.no_banner:
        os.environ['MACE_NO_BANNER'] = '1'
    
    # Show banner unless suppressed or showing help or running with arguments
    if not args.no_banner and args.command and args.command != 'version' and not args.args:
        show_banner()
    
    # If no command, show help
    if not args.command:
        if '--help' not in sys.argv and '-h' not in sys.argv and not args.no_banner:
            # Show main banner for help
            if BANNER_AVAILABLE:
                print_banner('banner')  # Use main banner instead of compact
        parser.print_help()
        sys.exit(0)
    
    # Reconstruct sys.argv for the subcommands, preserving --no-banner if present
    sys.argv = [sys.argv[0]] + args.args + remaining
    if args.no_banner and '--no-banner' not in sys.argv:
        sys.argv.append('--no-banner')
    
    # Handle commands
    if args.command == 'workflow':
        # Default to run_mace.py
        from run_mace import main as run_mace_main
        run_mace_main()
        
    elif args.command == 'submit':
        # Handle submission commands
        if not args.args:
            print("Usage: mace submit <file_or_directory>")
            sys.exit(1)
        
        target = args.args[0]
        
        # Check what type of files we're dealing with
        if os.path.isfile(target):
            # Single file submission
            sys.argv = ['submit_script', target]
            if target.endswith('.d3'):
                from submission.properties import main as submit_properties
                submit_properties()
            elif target.endswith('.d12'):
                from submission.crystal import main as submit_crystal
                submit_crystal()
            else:
                print(f"Error: {target} is not a D12 or D3 file")
                sys.exit(1)
        
        elif os.path.isdir(target):
            # Directory submission - check what files are present
            files = os.listdir(target)
            d12_files = [f for f in files if f.endswith('.d12') and os.path.isfile(os.path.join(target, f))]
            d3_files = [f for f in files if f.endswith('.d3') and os.path.isfile(os.path.join(target, f))]
            
            if not d12_files and not d3_files:
                print(f"No D12 or D3 files found in {target}")
                sys.exit(1)
            
            # Handle mixed directories
            if d12_files and d3_files:
                print(f"\nFound both D12 and D3 files in {target}:")
                print(f"  {len(d12_files)} D12 file(s) (CRYSTAL calculations)")
                print(f"  {len(d3_files)} D3 file(s) (property calculations)")
                print("\nWhat would you like to submit?")
                print("1. D12 files only")
                print("2. D3 files only")
                print("3. Both D12 and D3 files")
                
                choice = input("\nSelect option (1-3): ").strip()
                
                if choice == '1':
                    # Submit D12 only
                    sys.argv = ['submit_script', target]
                    from submission.crystal import main as submit_crystal
                    submit_crystal()
                elif choice == '2':
                    # Submit D3 only
                    sys.argv = ['submit_script', target]
                    from submission.properties import main as submit_properties
                    submit_properties()
                elif choice == '3':
                    # Submit both
                    print("\n=== Submitting D12 files ===")
                    sys.argv = ['submit_script', target]
                    from submission.crystal import main as submit_crystal
                    submit_crystal()
                    
                    print("\n=== Submitting D3 files ===")
                    sys.argv = ['submit_script', target]
                    from submission.properties import main as submit_properties
                    submit_properties()
                else:
                    print("Invalid choice. Exiting.")
                    sys.exit(1)
            
            elif d12_files:
                # Only D12 files
                sys.argv = ['submit_script', target]
                from submission.crystal import main as submit_crystal
                submit_crystal()
            
            else:
                # Only D3 files
                sys.argv = ['submit_script', target]
                from submission.properties import main as submit_properties
                submit_properties()
        
        else:
            print(f"Error: {target} is not a valid file or directory")
            sys.exit(1)
            
    elif args.command == 'monitor':
        # Launch monitoring dashboard or show status
        # Combine all arguments
        all_args = args.args + remaining
        
        # Check if we should show quick status instead of dashboard
        if '--status' in all_args or '--summary' in all_args or '--detailed' in all_args:
            # Show status information
            from database.materials_contextual import ContextualMaterialDatabase
            from workflow.context import get_current_context
            
            # Parse status arguments
            material_id = None
            workflow_id = None
            detailed = '--detailed' in all_args
            summary = '--summary' in all_args
            
            i = 0
            while i < len(all_args):
                if all_args[i] == '--material-id' and i + 1 < len(all_args):
                    material_id = all_args[i + 1]
                    i += 2
                elif all_args[i] == '--workflow-id' and i + 1 < len(all_args):
                    workflow_id = all_args[i + 1]
                    i += 2
                else:
                    i += 1
            
            # Initialize database
            db = ContextualMaterialDatabase()
            
            # Show context information
            ctx = get_current_context()
            if ctx:
                print(f"\n=== MACE Status (Workflow: {ctx.workflow_id}) ===")
                print(f"Isolation Mode: {ctx.isolation_mode}")
                print(f"Database: {ctx.db_path}")
            else:
                print("\n=== MACE Status ===")
            
            # Get statistics
            stats = db.get_database_stats()
            print(f"\nMaterials: {stats.get('total_materials', 0)}")
            
            # Calculate total calculations
            status_dist = stats.get('calculations_by_status', {})
            total_calcs = sum(status_dist.values())
            print(f"Calculations: {total_calcs}")
            
            # Show status distribution
            if status_dist and not summary:
                print(f"  Pending: {status_dist.get('pending', 0)}")
                print(f"  Running: {status_dist.get('running', 0)}")  
                print(f"  Completed: {status_dist.get('completed', 0)}")
                print(f"  Failed: {status_dist.get('failed', 0)}")
            
            if detailed and not summary:
                # Show calculation types
                calc_types = stats.get('calculations_by_type', {})
                if calc_types:
                    print("\nCalculation Types:")
                    for calc_type, count in calc_types.items():
                        print(f"  {calc_type}: {count}")
                
                # Show recent activity
                recent_calcs = db.get_recent_calculations(limit=10)
                if recent_calcs:
                    print("\nRecent Activity:")
                    for calc in recent_calcs:
                        print(f"  {calc['calc_id']} ({calc['material_id']}): {calc['status']}")
                        if calc.get('error_message'):
                            print(f"    Error: {calc['error_message']}")
            
            elif not summary:
                # Standard view - show last 5 calculations
                recent_calcs = db.get_recent_calculations(limit=5)
                if recent_calcs:
                    print("\nRecent Activity:")
                    for calc in recent_calcs:
                        print(f"  {calc['calc_id']} ({calc['material_id']}): {calc['status']}")
            
        else:
            # Run normal monitor dashboard
            from material_monitor import main as monitor_main
            if not any(arg in all_args for arg in ['--action']):
                # Default to dashboard if no specific action
                sys.argv = ['material_monitor.py', '--action', 'dashboard'] + all_args
            else:
                # Pass through all arguments
                sys.argv = ['material_monitor.py'] + all_args
            monitor_main()
        
    elif args.command == 'analyze':
        # Property analysis
        all_args = args.args + remaining
        if '--extract-properties' in all_args:
            from utils.property_extractor import main as extract_main
            # Pass all arguments to property extractor
            sys.argv = ['property_extractor.py'] + all_args
            extract_main()
        else:
            print("Usage: mace analyze --extract-properties <directory> [options]")
            print("Run 'mace analyze --help' for full options")
            
    # These commands are handled in the passthrough section above
    elif args.command in ['convert', 'opt2d12', 'opt2d3']:
        # Should never reach here, but just in case
        pass
            
    elif args.command == 'credits':
        # Credits already shown in banner if banner was displayed
        # Only show credits here if banner was suppressed
        if args.no_banner:
            if BANNER_AVAILABLE:
                print(get_credits())
            else:
                print("\nMACE Development Team:")
                print("Primary Developer: Marcus Djokic")
                print("Contributors: Daniel Maldonado Lopez, Brandon Lewis, Dr. William Comaskey")
                print("PI: Prof. Jose Luis Mendoza-Cortes")
            
    elif args.command == 'status':
        # Redirect to monitor --status for backward compatibility
        print("Note: 'mace status' has been merged into 'mace monitor --status'")
        args.command = 'monitor'
        args.args = ['--status'] + args.args
        # Re-process as monitor command
        sys.argv = [sys.argv[0], 'monitor', '--status'] + args.args
        main()  # Recursive call to handle as monitor
        return
    elif args.command == 'manager':
        # Enhanced Queue Manager command
        from queue.manager import EnhancedCrystalQueueManager
        
        # Combine all arguments
        all_args = args.args + remaining
        
        # Parse queue arguments
        max_jobs = 250
        reserve = 30
        callback_mode = None
        dry_run = False
        show_status = False
        base_dir = '.'
        
        i = 0
        while i < len(all_args):
            if all_args[i] == '--status':
                show_status = True
                i += 1
            elif all_args[i] == '--max-jobs' and i + 1 < len(all_args):
                max_jobs = int(all_args[i + 1])
                i += 2
            elif all_args[i] == '--reserve' and i + 1 < len(all_args):
                reserve = int(all_args[i + 1])
                i += 2
            elif all_args[i] == '--callback-mode' and i + 1 < len(all_args):
                callback_mode = all_args[i + 1]
                i += 2
            elif all_args[i] == '--dry-run':
                dry_run = True
                i += 1
            elif all_args[i] == '--d12-dir' and i + 1 < len(all_args):
                base_dir = all_args[i + 1]
                i += 2
            else:
                i += 1
        
        # Initialize queue manager
        manager = EnhancedCrystalQueueManager(
            d12_dir=base_dir,
            max_jobs=max_jobs, 
            reserve_slots=reserve
        )
        
        if show_status:
            # Show queue status using the check_queue method
            try:
                running, pending = manager.check_queue()
                available = max_jobs - running
                
                print("\n=== Queue Status ===")
                print(f"Running Jobs: {running}")
                print(f"Pending Jobs: {pending}")
                print(f"Available Slots: {available}")
                print(f"Max Jobs: {max_jobs}")
                print(f"Reserved Slots: {reserve}")
            except Exception as e:
                print("\n=== Queue Status ===")
                print(f"Error: Unable to check SLURM queue - {e}")
                print("\nNote: This command requires SLURM to be available.")
                print("On non-SLURM systems, use 'mace monitor --status' for database statistics.")
        else:
            # Run queue manager
            print(f"Running queue manager (max_jobs={max_jobs}, reserve={reserve})...")
            
            # The manager needs to be called with proper arguments
            from queue.manager import main as queue_main
            
            # Build argument list
            sys.argv = ['queue_manager.py', '--d12-dir', base_dir, 
                       '--max-jobs', str(max_jobs), '--reserve', str(reserve)]
            
            if callback_mode:
                sys.argv.extend(['--callback-mode', callback_mode])
            
            if dry_run:
                sys.argv.append('--dry-run')
                
            # Call the main function
            queue_main()
    
    elif args.command == 'queue':
        # Redirect to manager command for backward compatibility
        print("Note: 'mace queue' is deprecated. Use 'mace manager' instead.")
        print("This command will be removed in a future version.\n")
        args.command = 'manager'
        # Re-process as manager command
        sys.argv = [sys.argv[0], 'manager'] + args.args
        main()  # Recursive call to handle as manager
        return
        
    elif args.command == 'recover':
        # Error recovery command
        from recovery.recovery import main as recovery_main
        # Combine all arguments
        all_args = args.args + remaining
        sys.argv = ['recovery.py'] + all_args
        recovery_main()
        
    elif args.command == 'database':
        # Database management command
        from database.materials_contextual import ContextualMaterialDatabase
        import csv
        
        # Parse database arguments from remaining args
        # Need to reconstruct the arguments correctly
        # When user types: mace database --action properties
        # We get: args.args = [] and remaining = ['--action', 'properties']
        # But argparse sometimes splits them incorrectly
        
        # Reconstruct the full argument list from original_argv
        # Find where 'database' is in original_argv and take everything after it
        try:
            db_index = original_argv.index('database')
            all_args = original_argv[db_index + 1:]
            # Remove --no-banner if present
            all_args = [arg for arg in all_args if arg != '--no-banner']
        except (ValueError, NameError):
            # Fallback to original method
            all_args = args.args + remaining
            
        # Check for action-specific help
        if '--help' in all_args and '--action' in all_args:
            action_index = all_args.index('--action')
            if action_index + 1 < len(all_args):
                action = all_args[action_index + 1]
                show_action_help(action)
                return
        action = 'stats'
        material_id = None
        calc_type = None
        status = None
        export_csv = None
        
        i = 0
        while i < len(all_args):
            if all_args[i] == '--action' and i + 1 < len(all_args):
                action = all_args[i + 1]
                i += 2
            elif all_args[i] == '--material-id' and i + 1 < len(all_args):
                material_id = all_args[i + 1]
                i += 2
            elif all_args[i] == '--calc-type' and i + 1 < len(all_args):
                calc_type = all_args[i + 1]
                i += 2
            elif all_args[i] == '--status' and i + 1 < len(all_args):
                status = all_args[i + 1]
                i += 2
            elif all_args[i] == '--export-csv' and i + 1 < len(all_args):
                export_csv = all_args[i + 1]
                i += 2
            else:
                i += 1
        
        # Initialize database
        db = ContextualMaterialDatabase()
        
        # Debug: show what action was selected
        # print(f"DEBUG: Selected action = '{action}', all_args = {all_args}")
        
        if action == 'stats':
            # Show database statistics
            stats = db.get_database_stats()
            print("\n=== Database Statistics ===")
            print(f"Total Materials: {stats.get('total_materials', 0)}")
            
            # Calculate total calculations
            status_dist = stats.get('calculations_by_status', {})
            total_calcs = sum(status_dist.values())
            print(f"Total Calculations: {total_calcs}")
            
            # Get calculation types
            calc_types = stats.get('calculations_by_type', {})
            if calc_types:
                print("\nCalculation Types:")
                for calc_type, count in calc_types.items():
                    print(f"  {calc_type}: {count}")
            
            # Get status distribution
            status_dist = stats.get('calculations_by_status', {})
            if status_dist:
                print("\nStatus Distribution:")
                for status, count in status_dist.items():
                    print(f"  {status}: {count}")
            
            # Add hint about other actions
            print("\nUse --action query to list materials")
            print("Use --action export --export-csv FILE to export data")
                
        elif action == 'query':
            # Parse filter options
            filter_strings = []
            filter_logic = 'AND'
            i = 0
            while i < len(all_args):
                if all_args[i] == '--filter' and i + 1 < len(all_args):
                    filter_strings.append(all_args[i + 1])
                    i += 2
                elif all_args[i] == '--logic' and i + 1 < len(all_args):
                    filter_logic = all_args[i + 1].upper()
                    i += 2
                else:
                    i += 1
            
            # Query database
            if material_id:
                material = db.get_material(material_id)
                if material:
                    print(f"\n=== Material: {material_id} ===")
                    for key, value in material.items():
                        if key != 'structure_json':  # Skip large JSON fields
                            print(f"{key}: {value}")
                    
                    # Get calculations
                    calcs = db.get_calculations_by_status(material_id=material_id)
                    if calcs:
                        print(f"\nCalculations ({len(calcs)}):")
                        for calc in calcs:
                            print(f"  {calc['calc_id']} ({calc['calc_type']}): {calc['status']}")
                else:
                    print(f"Material '{material_id}' not found")
            else:
                # General query - list all materials
                if filter_strings:
                    # Apply property filters
                    try:
                        # Check if it's a single advanced filter expression
                        # Look for special operators or single = sign (not ==)
                        advanced_indicators = ['(', ')', ' AND ', ' OR ', ' LIKE ', ' IN ', ' IS ']
                        is_advanced = False
                        if len(filter_strings) == 1:
                            upper_filter = filter_strings[0].upper()
                            # Check for advanced operators
                            for op in advanced_indicators:
                                if op in upper_filter:
                                    is_advanced = True
                                    break
                            # Also check for single = (SQL style) but not ==
                            if not is_advanced and '=' in filter_strings[0] and '==' not in filter_strings[0] and '!=' not in filter_strings[0] and '<=' not in filter_strings[0] and '>=' not in filter_strings[0]:
                                is_advanced = True
                        
                        if is_advanced:
                            # Use advanced filtering
                            materials = db.filter_materials_advanced(filter_strings[0])
                            print(f"\n=== Filtered Materials ({len(materials)} matching) ===")
                            print(f"Advanced filter: {filter_strings[0]}")
                        else:
                            # Use regular filtering
                            materials = db.filter_materials_by_properties(filter_strings, filter_logic)
                            print(f"\n=== Filtered Materials ({len(materials)} matching) ===")
                            if filter_strings:
                                print(f"Filters ({filter_logic}): {', '.join(filter_strings)}")
                    except Exception as e:
                        print(f"Error applying filters: {e}")
                        materials = []
                else:
                    materials = db.get_all_materials()
                print(f"\n=== All Materials in Database ({len(materials)} total) ===")
                print(f"{'Material ID':<30} {'Formula':<20} {'Space Group':<15} {'Created':<20}")
                print("-" * 85)
                
                for mat in materials[:20]:  # Show first 20
                    material_id = mat['material_id'][:30]  # Truncate long IDs
                    formula = mat.get('formula', 'Unknown')[:20]
                    space_group = str(mat.get('space_group', 'Unknown'))[:15]
                    created = mat.get('created_at', 'Unknown')[:20]
                    print(f"{material_id:<30} {formula:<20} {space_group:<15} {created:<20}")
                    
                if len(materials) > 20:
                    print(f"\n... and {len(materials) - 20} more materials")
                    print("Use --material-id <ID> to see details for a specific material")
                    
        elif action == 'properties':
            # Parse additional filtering options
            category_filter = None
            calc_type_filter = None
            show_json = False
            compact = False
            units_map = {}
            show_all_units = False
            
            # Continue parsing arguments for filters
            i = 0
            while i < len(all_args):
                if all_args[i] == '--category' and i + 1 < len(all_args):
                    category_filter = all_args[i + 1]
                    i += 2
                elif all_args[i] == '--from-calc' and i + 1 < len(all_args):
                    calc_type_filter = all_args[i + 1].upper()
                    i += 2
                elif all_args[i] == '--json':
                    show_json = True
                    i += 1
                elif all_args[i] == '--compact':
                    compact = True
                    i += 1
                elif all_args[i] == '--units' and i + 1 < len(all_args):
                    # Parse unit conversion map
                    units_str = all_args[i + 1]
                    for unit_spec in units_str.split(','):
                        if ':' in unit_spec:
                            prop, unit = unit_spec.split(':', 1)
                            units_map[prop.strip()] = unit.strip()
                    i += 2
                elif all_args[i] == '--all-units':
                    show_all_units = True
                    i += 1
                else:
                    i += 1
            
            # Show all available units if requested
            if show_all_units:
                from mace.database.utils import get_property_units, get_default_unit
                
                print("\n=== Available Units for Properties ===\n")
                
                # Common properties with units
                properties_with_units = [
                    'total_energy', 'fermi_energy', 'band_gap', 'cohesive_energy',
                    'a_lattice', 'b_lattice', 'c_lattice', 'cell_volume',
                    'alpha', 'beta', 'gamma',
                    'pressure', 'bulk_modulus', 'young_modulus',
                    'phonon_frequencies', 'temperature'
                ]
                
                for prop in properties_with_units:
                    units = get_property_units(prop)
                    if units:
                        default = get_default_unit(prop)
                        print(f"{prop}:")
                        units_str = ", ".join(units)
                        if default:
                            print(f"  Units: {units_str}")
                            print(f"  Default: {default}")
                        else:
                            print(f"  Units: {units_str}")
                        print()
                
                print("Use --units \"property:unit\" to convert units during display")
                print("Example: --units \"band_gap:eV,total_energy:kcal/mol\"")
                return
            
            # Show material properties and statistics
            if material_id:
                # Show properties for specific material
                props = db.get_material_properties(material_id)
                
                # Filter by calculation type if requested
                if calc_type_filter and props:
                    filtered_props = []
                    for prop in props:
                        if prop.get('calc_id'):
                            # Get calculation info
                            calc_info = db.get_calculation(prop['calc_id'])
                            if calc_info and calc_info.get('calc_type') == calc_type_filter:
                                filtered_props.append(prop)
                    props = filtered_props
                
                if props:
                    # Get material info for header
                    mat_info = db.get_material(material_id)
                    
                    print(f"\n{'=' * 70}")
                    print(f"Material: {material_id}")
                    if mat_info:
                        print(f"Formula: {mat_info.get('formula', 'N/A')}")
                        print(f"Space Group: {mat_info.get('space_group', 'N/A')}")
                    if calc_type_filter:
                        print(f"Properties from: {calc_type_filter} calculations only")
                    print(f"{'=' * 70}")
                    
                    # Group properties by category
                    props_by_category = {}
                    for prop in props:
                        category = prop.get('property_category', 'General')
                        if category_filter and category.lower() != category_filter.lower():
                            continue
                        if category not in props_by_category:
                            props_by_category[category] = []
                        props_by_category[category].append(prop)
                    
                    if not props_by_category:
                        print(f"\nNo properties found matching filters.")
                        if category_filter:
                            print(f"Category filter: {category_filter}")
                        if calc_type_filter:
                            print(f"Calculation type filter: {calc_type_filter}")
                    else:
                        # Display properties by category
                        for category, cat_props in sorted(props_by_category.items()):
                            if not compact:
                                print(f"\n{'-' * 50}")
                                print(f"{category.upper()}")
                                print(f"{'-' * 50}")
                            else:
                                print(f"\n{category}:")
                            
                            # Sort properties with custom ordering
                            def property_sort_key(prop):
                                name = prop['property_name']
                                # Priority order for common prefixes
                                if name.startswith('initial_'):
                                    return (0, name)
                                elif name.startswith('final_'):
                                    return (1, name)
                                else:
                                    return (2, name)
                            
                            cat_props.sort(key=property_sort_key)
                            
                            # Determine if we should show JSON for this category
                            has_json = any('JSON' in str(p.get('property_unit', '')) or 
                                         isinstance(p['property_value'], (dict, list)) or
                                         (isinstance(p['property_value'], str) and 
                                          (p['property_value'].startswith('[') or p['property_value'].startswith('{')))
                                         for p in cat_props)
                            
                            for prop in cat_props:
                                value = prop['property_value']
                                unit = prop.get('property_unit', '')
                                name = prop['property_name']
                                
                                # Format property name nicely
                                display_name = name.replace('_', ' ').title()
                                
                                # Check if value is JSON or complex data
                                is_json_value = (unit == 'JSON' or 
                                               isinstance(value, (dict, list)) or
                                               (isinstance(value, str) and 
                                                (value.startswith('[') or value.startswith('{'))))
                                
                                if is_json_value and not show_json:
                                    # Show simplified version for JSON data
                                    if compact:
                                        print(f"  {name}: <complex data>")
                                    else:
                                        print(f"  {display_name:.<40} <complex data - use --json to show>")
                                elif is_json_value and show_json:
                                    # Show full JSON data
                                    print(f"  {display_name}:")
                                    if isinstance(value, str):
                                        try:
                                            import json
                                            parsed = json.loads(value)
                                            print(f"    {json.dumps(parsed, indent=4)}")
                                        except:
                                            print(f"    {value}")
                                    else:
                                        import json
                                        print(f"    {json.dumps(value, indent=4)}")
                                else:
                                    # Check if unit conversion requested
                                    display_value = value
                                    display_unit = unit
                                    
                                    if name in units_map and isinstance(value, (int, float)):
                                        try:
                                            from mace.database.utils import convert_units
                                            # Convert from stored unit to requested unit
                                            if unit:  # If we have a source unit
                                                converted_value = convert_units(float(value), unit, units_map[name], name)
                                                display_value = converted_value
                                                display_unit = units_map[name]
                                        except Exception as e:
                                            # Conversion failed, show original
                                            pass
                                    
                                    # Format numeric values nicely
                                    if isinstance(display_value, float):
                                        # Use appropriate precision based on magnitude
                                        if abs(display_value) < 0.001 or abs(display_value) > 10000:
                                            value_str = f"{display_value:.6e}"
                                        else:
                                            value_str = f"{display_value:.6f}".rstrip('0').rstrip('.')
                                    else:
                                        value_str = str(display_value)
                                    
                                    if compact:
                                        print(f"  {name}: {value_str} {display_unit}".strip())
                                    else:
                                        # Aligned display with dots
                                        if display_unit:
                                            print(f"  {display_name:.<40} {value_str} {display_unit}")
                                        else:
                                            print(f"  {display_name:.<40} {value_str}")
                        
                        # Show summary
                        total_props = sum(len(props) for props in props_by_category.values())
                        print(f"\n{'-' * 50}")
                        print(f"Total properties: {total_props}")
                        print(f"Categories: {', '.join(sorted(props_by_category.keys()))}")
                        
                        # Show available options
                        print(f"\nOptions:")
                        print(f"  --category <name>   Show only properties from specific category")
                        print(f"  --from-calc <type>  Show only properties from specific calculation type")
                        print(f"  --compact           Compact display format")
                        print(f"  --json              Show full JSON data for complex properties")
                        
                else:
                    print(f"\nNo properties found for material '{material_id}'")
                    if calc_type_filter:
                        print(f"(filtered by calculation type: {calc_type_filter})")
            else:
                # Show property statistics across all materials
                # Check for formatting options and filters
                compact = '--compact' in all_args
                show_json = '--json' in all_args
                
                # Parse category filter
                category_filter = None
                for i, arg in enumerate(all_args):
                    if arg == '--category' and i + 1 < len(all_args):
                        category_filter = all_args[i + 1]
                        break
                
                # Get all properties
                all_props = db.get_all_properties()
                
                if all_props:
                    # Count materials with properties
                    materials_with_props = set()
                    prop_counts = {}
                    prop_values = {}
                    prop_categories = {}
                    prop_units = {}
                    prop_by_category = {}
                    
                    for prop in all_props:
                        materials_with_props.add(prop['material_id'])
                        prop_name = prop['property_name']
                        category = prop.get('property_category', 'Other')
                        unit = prop.get('property_unit', '')
                        
                        # Count occurrences
                        if prop_name not in prop_counts:
                            prop_counts[prop_name] = 0
                            prop_values[prop_name] = []
                            prop_categories[prop_name] = category
                            prop_units[prop_name] = unit
                        prop_counts[prop_name] += 1
                        
                        # Group by category
                        if category not in prop_by_category:
                            prop_by_category[category] = {}
                        prop_by_category[category][prop_name] = prop_counts[prop_name]
                        
                        # Collect values for numeric properties
                        try:
                            value = float(prop['property_value'])
                            prop_values[prop_name].append(value)
                        except (ValueError, TypeError):
                            pass
                    
                    # Display header
                    if not compact:
                        print("\n" + "=" * 70)
                        print("PROPERTY STATISTICS DATABASE")
                        print("=" * 70)
                        print(f"\nMaterials with properties: {len(materials_with_props)}")
                        print(f"Total property entries: {len(all_props)}")
                        print(f"Unique properties tracked: {len(prop_counts)}")
                    else:
                        print("\n=== Property Statistics ===")
                        print(f"Materials with properties: {len(materials_with_props)}")
                        print(f"Total property entries: {len(all_props)}")
                    
                    # Skip certain non-meaningful properties in stats
                    skip_props = ['advanced_analysis_available', 'has_dielectric_data',
                                  'advanced_analysis_note', 'dielectric_extraction_note',
                                  'calculation_type', 'neighbor_analysis', 'vibrational_temperatures',
                                  'has_normal_mode_displacements', 'has_force_constants',
                                  'has_FREQUENCY_data', 'atomic_positions', 'final_atomic_positions',
                                  'initial_initial_atomic_positions', 'final_final_atomic_positions',
                                  'mulliken_alpha_plus_beta', 'mulliken_alpha_minus_beta',
                                  'overlap_population_alpha_plus_beta', 'overlap_population_alpha_minus_beta']
                    
                    # Define category order for consistent sorting
                    category_order = ['structural', 'lattice', 'electronic', 'electronic_classification',
                                    'optimization', 'computational', 'thermodynamic', 'vibrational',
                                    'crystallographic', 'population_analysis', 'other']
                    
                    if not compact:
                        # Show property availability by category
                        print("\n" + "-" * 50)
                        print("PROPERTY AVAILABILITY BY CATEGORY")
                        print("-" * 50)
                        
                        sorted_categories = sorted(prop_by_category.items(), 
                                                 key=lambda x: (category_order.index(x[0].lower()) 
                                                               if x[0].lower() in category_order else 999, x[0]))
                        
                        # Apply category filter if specified
                        if category_filter:
                            sorted_categories = [(cat, props) for cat, props in sorted_categories 
                                               if cat.lower() == category_filter.lower()]
                            if not sorted_categories:
                                print(f"\nNo properties found in category '{category_filter}'")
                                print(f"Available categories: {', '.join(sorted(prop_by_category.keys()))}")
                                return
                        
                        for category, props in sorted_categories:
                            print(f"\n{category.upper()}:")
                            # Sort properties within category
                            def prop_sort_key(item):
                                name = item[0]
                                if name.startswith('initial_'):
                                    return (0, name)
                                elif name.startswith('final_'):
                                    return (1, name)
                                else:
                                    return (2, name)
                            
                            sorted_props = sorted(props.items(), key=prop_sort_key)
                            for prop_name, count in sorted_props:
                                display_name = prop_name.replace('_', ' ').title()
                                print(f"  {display_name:.<50} {count} materials")
                    else:
                        # Compact view - just show counts
                        print("\nProperty availability:")
                        
                        # Apply category filter if specified
                        if category_filter:
                            filtered_props = {name: count for name, count in prop_counts.items()
                                            if prop_categories.get(name, 'Other').lower() == category_filter.lower()}
                            if not filtered_props:
                                print(f"\nNo properties found in category '{category_filter}'")
                                print(f"Available categories: {', '.join(sorted(set(prop_categories.values())))}")
                                return
                            props_to_show = filtered_props
                            print(f"Category: {category_filter.upper()}")
                        else:
                            props_to_show = prop_counts
                        
                        sorted_props = sorted(props_to_show.items(), key=lambda x: x[1], reverse=True)
                        for prop_name, count in sorted_props[:20]:
                            print(f"  {prop_name}: {count} materials")
                        if len(sorted_props) > 20:
                            print(f"  ... and {len(sorted_props) - 20} more properties")
                    
                    # Show statistics for numeric properties
                    if not compact:
                        print("\n" + "-" * 50)
                        print("NUMERIC PROPERTY RANGES")
                        print("-" * 50)
                    else:
                        print("\nNumeric property ranges:")
                    
                    # Group numeric properties by category
                    numeric_by_category = {}
                    for prop_name, values in prop_values.items():
                        if values and len(values) >= 1 and prop_name not in skip_props:
                            category = prop_categories.get(prop_name, 'Other')
                            if category not in numeric_by_category:
                                numeric_by_category[category] = {}
                            numeric_by_category[category][prop_name] = values
                    
                    # Display numeric properties by category
                    if numeric_by_category:
                        sorted_num_categories = sorted(numeric_by_category.items(), 
                                                     key=lambda x: (category_order.index(x[0].lower()) 
                                                                   if x[0].lower() in category_order else 999, x[0]))
                        
                        # Apply category filter if specified
                        if category_filter:
                            sorted_num_categories = [(cat, props) for cat, props in sorted_num_categories 
                                                   if cat.lower() == category_filter.lower()]
                        
                        for category, props in sorted_num_categories:
                            if not compact:
                                print(f"\n{category.upper()}:")
                            
                            # Sort properties within category
                            def prop_sort_key(item):
                                name = item[0]
                                if name.startswith('initial_'):
                                    return (0, name)
                                elif name.startswith('final_'):
                                    return (1, name)
                                else:
                                    return (2, name)
                            
                            sorted_props = sorted(props.items(), key=prop_sort_key)
                            
                            for prop_name, values in sorted_props:
                                min_val = min(values)
                                max_val = max(values)
                                avg_val = sum(values) / len(values)
                                unit = prop_units.get(prop_name, '')
                                
                                if compact:
                                    # Compact format
                                    print(f"  {prop_name}: min={min_val:.3g}, max={max_val:.3g}, avg={avg_val:.3g} {unit}".strip())
                                else:
                                    # Full format
                                    display_name = prop_name.replace('_', ' ').title()
                                    print(f"\n  {display_name}:")
                                    
                                    # Format values based on magnitude
                                    if abs(min_val) < 0.001 or abs(min_val) > 10000:
                                        min_str = f"{min_val:.6e}"
                                    else:
                                        min_str = f"{min_val:.6f}".rstrip('0').rstrip('.')
                                    
                                    if abs(max_val) < 0.001 or abs(max_val) > 10000:
                                        max_str = f"{max_val:.6e}"
                                    else:
                                        max_str = f"{max_val:.6f}".rstrip('0').rstrip('.')
                                    
                                    if abs(avg_val) < 0.001 or abs(avg_val) > 10000:
                                        avg_str = f"{avg_val:.6e}"
                                    else:
                                        avg_str = f"{avg_val:.6f}".rstrip('0').rstrip('.')
                                    
                                    print(f"    Minimum....................... {min_str} {unit}")
                                    print(f"    Maximum....................... {max_str} {unit}")
                                    print(f"    Average....................... {avg_str} {unit}")
                                    print(f"    Materials with data.......... {len(values)}")
                                    
                                    if show_json:
                                        # Show distribution data
                                        print(f"    Distribution:")
                                        import json
                                        dist_data = {
                                            "values": sorted(values)[:10],  # First 10 values
                                            "count": len(values),
                                            "std_dev": (sum((x - avg_val)**2 for x in values) / len(values))**0.5 if len(values) > 1 else 0
                                        }
                                        print(f"      {json.dumps(dist_data, indent=6)}")
                    
                    if not compact:
                        # Show summary and options
                        print("\n" + "=" * 70)
                        print("\nOptions:")
                        print("  --material-id ID    View properties for a specific material")
                        print("  --category <name>   Show only properties from specific category")
                        print("  --compact           Compact display format")
                        print("  --json              Show distribution data for numeric properties")
                        
                        print("\nExamples:")
                        print("  mace database --action properties --compact")
                        print("  mace database --action properties --json")
                        print("  mace database --action properties --category electronic")
                        print("  mace database --action properties --material-id 1_dia")
                else:
                    print("No properties found in database")
                    
                if compact:
                    print("\nUse --material-id ID to see properties for a specific material")
                    print("Use without --compact for detailed view")
                    
        elif action == 'export':
            # Parse export options
            export_format = 'csv'  # default
            output_file = export_csv
            include_properties = []
            include_structures = False
            properties_only = False
            filter_strings = []
            filter_logic = 'AND'
            
            # Parse additional export arguments
            i = 0
            while i < len(all_args):
                if all_args[i] == '--format' and i + 1 < len(all_args):
                    export_format = all_args[i + 1].lower()
                    i += 2
                elif all_args[i] == '--output' and i + 1 < len(all_args):
                    output_file = all_args[i + 1]
                    i += 2
                elif all_args[i] == '--include-property' and i + 1 < len(all_args):
                    include_properties.append(all_args[i + 1])
                    i += 2
                elif all_args[i] == '--include-structures':
                    include_structures = True
                    i += 1
                elif all_args[i] == '--properties-only':
                    properties_only = True
                    i += 1
                elif all_args[i] == '--filter' and i + 1 < len(all_args):
                    filter_strings.append(all_args[i + 1])
                    i += 2
                elif all_args[i] == '--logic' and i + 1 < len(all_args):
                    filter_logic = all_args[i + 1].upper()
                    i += 2
                else:
                    i += 1
                    
            # Use new export functionality
            try:
                from database.export import export_materials
                
                # Handle include_properties
                if not include_properties:
                    include_properties = None  # Include all
                    
                exported_file = export_materials(
                    db,
                    format=export_format,
                    output_file=output_file,
                    filters=filter_strings,
                    logic=filter_logic,
                    properties_only=properties_only,
                    include_properties=include_properties,
                    include_structures=include_structures
                )
                
                if exported_file:
                    print(f"\nSuccessfully exported to: {exported_file}")
                    print(f"Format: {export_format}")
                    
                    # Show what was exported
                    if properties_only:
                        print("Exported: All properties")
                    elif filter_strings:
                        print(f"Exported: Filtered materials ({filter_logic} logic)")
                        for f in filter_strings:
                            print(f"  - {f}")
                    else:
                        print("Exported: All materials")
                        
                    if include_properties and not properties_only:
                        print(f"Included properties: {', '.join(include_properties)}")
                else:
                    print("Export failed.")
                    
            except ImportError as e:
                print(f"Error: {e}")
                print("\nFalling back to basic CSV export...")
                # Fallback to basic export
                if output_file:
                    materials = db.get_all_materials()
                    import csv
                    with open(output_file, 'w', newline='') as f:
                        if materials:
                            writer = csv.DictWriter(f, fieldnames=materials[0].keys())
                            writer.writeheader()
                            writer.writerows(materials)
                    print(f"Exported {len(materials)} materials to {output_file}")
                else:
                    print("Please specify --export-csv FILE or --output FILE")
            except Exception as e:
                print(f"Export error: {e}")
                
        elif action == 'compare':
            # Compare materials
            # Parse compare-specific arguments
            materials_to_compare = []
            properties_to_compare = []
            output_format = 'table'
            
            i = 0
            while i < len(all_args):
                if all_args[i] == '--materials' and i + 1 < len(all_args):
                    # Parse comma-separated list
                    materials_to_compare = all_args[i + 1].split(',')
                    i += 2
                elif all_args[i] == '--properties' and i + 1 < len(all_args):
                    # Parse comma-separated list
                    properties_to_compare = all_args[i + 1].split(',')
                    i += 2
                elif all_args[i] == '--output-format' and i + 1 < len(all_args):
                    output_format = all_args[i + 1].lower()
                    i += 2
                else:
                    i += 1
                    
            if not materials_to_compare:
                print("Error: Please specify materials to compare with --materials")
                print("Example: mace database --action compare --materials '1_dia,2_dia2,3_dia3'")
            else:
                try:
                    from database.analysis import compare_materials
                    
                    # If no properties specified, compare all
                    if not properties_to_compare:
                        properties_to_compare = None
                        
                    result = compare_materials(
                        db,
                        materials_to_compare,
                        properties_to_compare,
                        output_format
                    )
                    
                    print(result)
                    
                except ImportError as e:
                    print(f"Error importing comparison module: {e}")
                except Exception as e:
                    print(f"Comparison error: {e}")
                    
        elif action == 'missing':
            # Analyze missing data
            # Parse missing-specific arguments
            material_ids = []
            target_properties = []
            output_format = 'report'
            detail_level = 'summary'
            
            i = 0
            while i < len(all_args):
                if all_args[i] == '--material-ids' and i + 1 < len(all_args):
                    # Parse comma-separated list
                    material_ids = all_args[i + 1].split(',')
                    i += 2
                elif all_args[i] == '--target-properties' and i + 1 < len(all_args):
                    # Parse comma-separated list
                    target_properties = all_args[i + 1].split(',')
                    i += 2
                elif all_args[i] == '--output-format' and i + 1 < len(all_args):
                    output_format = all_args[i + 1].lower()
                    i += 2
                elif all_args[i] == '--detail-level' and i + 1 < len(all_args):
                    detail_level = all_args[i + 1].lower()
                    i += 2
                else:
                    i += 1
            
            try:
                from mace.database.analysis import analyze_missing_data
                result = analyze_missing_data(
                    db,
                    material_ids if material_ids else None,
                    target_properties if target_properties else None,
                    output_format,
                    detail_level
                )
                print(result)
            except Exception as e:
                print(f"Missing data analysis error: {e}")
                    
        elif action == 'correlate':
            # Calculate property correlations
            # Parse correlation-specific arguments
            property_pairs = []
            min_samples = 3
            output_format = 'report'
            top_n = 20
            
            i = 0
            while i < len(all_args):
                if all_args[i] == '--properties' and i + 1 < len(all_args):
                    # Parse property pairs like "band_gap,total_energy"
                    pairs_str = all_args[i + 1]
                    for pair in pairs_str.split(';'):
                        if ',' in pair:
                            prop1, prop2 = pair.split(',', 1)
                            property_pairs.append((prop1.strip(), prop2.strip()))
                    i += 2
                elif all_args[i] == '--min-samples' and i + 1 < len(all_args):
                    min_samples = int(all_args[i + 1])
                    i += 2
                elif all_args[i] == '--output-format' and i + 1 < len(all_args):
                    output_format = all_args[i + 1].lower()
                    i += 2
                elif all_args[i] == '--top-n' and i + 1 < len(all_args):
                    top_n = int(all_args[i + 1])
                    i += 2
                else:
                    i += 1
            
            try:
                from mace.database.analysis import calculate_property_correlations
                result = calculate_property_correlations(
                    db,
                    property_pairs if property_pairs else None,
                    min_samples,
                    output_format,
                    top_n
                )
                print(result)
            except Exception as e:
                print(f"Correlation analysis error: {e}")
                
        elif action == 'distribution' or action == 'distribute':
            # Analyze property distributions
            # Parse distribution-specific arguments
            properties = []
            n_bins = 10
            output_format = 'report'
            top_n = 10
            
            i = 0
            while i < len(all_args):
                if all_args[i] == '--properties' and i + 1 < len(all_args):
                    # Parse comma-separated properties
                    properties = [p.strip() for p in all_args[i + 1].split(',')]
                    i += 2
                elif all_args[i] == '--bins' and i + 1 < len(all_args):
                    n_bins = int(all_args[i + 1])
                    i += 2
                elif all_args[i] == '--output-format' and i + 1 < len(all_args):
                    output_format = all_args[i + 1].lower()
                    i += 2
                elif all_args[i] == '--top-n' and i + 1 < len(all_args):
                    top_n = int(all_args[i + 1])
                    i += 2
                else:
                    i += 1
            
            try:
                from mace.database.analysis import analyze_property_distributions
                result = analyze_property_distributions(
                    db,
                    properties if properties else None,
                    n_bins,
                    output_format,
                    top_n
                )
                print(result)
            except Exception as e:
                print(f"Distribution analysis error: {e}")
                
        elif action == 'workflow':
            # Track workflow progress
            material_ids = None
            workflow = None
            sequence = None
            detailed = False
            output_format = 'report'
            
            i = 0
            while i < len(remaining):
                if remaining[i] == '--material-ids' and i + 1 < len(remaining):
                    material_ids = [m.strip() for m in remaining[i + 1].split(',')]
                    i += 2
                elif remaining[i] == '--workflow' and i + 1 < len(remaining):
                    workflow = remaining[i + 1]
                    i += 2
                elif remaining[i] == '--sequence' and i + 1 < len(remaining):
                    sequence = [s.strip() for s in remaining[i + 1].split(',')]
                    i += 2
                elif remaining[i] == '--detailed':
                    detailed = True
                    i += 1
                elif remaining[i] == '--output-format' and i + 1 < len(remaining):
                    output_format = remaining[i + 1]
                    i += 2
                else:
                    i += 1
                    
            try:
                from mace.database.analysis import track_workflow_progress
                result = track_workflow_progress(
                    db,
                    material_ids,
                    workflow,
                    sequence,
                    output_format,
                    detailed
                )
                print(result)
            except Exception as e:
                print(f"Workflow tracking error: {e}")
                    
        elif action == 'validate':
            # Validate data integrity
            material_ids = None
            fix_issues = False
            check_integrity = False
            output_format = 'report'
            
            i = 0
            while i < len(remaining):
                if remaining[i] == '--material-ids' and i + 1 < len(remaining):
                    material_ids = [m.strip() for m in remaining[i + 1].split(',')]
                    i += 2
                elif remaining[i] == '--fix':
                    fix_issues = True
                    i += 1
                elif remaining[i] == '--check-integrity':
                    check_integrity = True
                    i += 1
                elif remaining[i] == '--output-format' and i + 1 < len(remaining):
                    output_format = remaining[i + 1]
                    i += 2
                else:
                    i += 1
                    
            try:
                from mace.database.utils import validate_materials, DatabaseValidator
                
                # Validate materials
                result = validate_materials(db, material_ids, fix_issues, output_format)
                print(result)
                
                # Check database integrity if requested
                if check_integrity:
                    validator = DatabaseValidator(db)
                    integrity_report = validator.check_database_integrity()
                    
                    print("\n=== Database Integrity Check ===")
                    print(f"Schema valid: {integrity_report['schema_valid']}")
                    print(f"Orphaned properties: {integrity_report['orphaned_properties']}")
                    print(f"Duplicate properties: {integrity_report['duplicate_properties']}")
                    
                    if integrity_report['integrity_issues']:
                        print("\nIntegrity issues found:")
                        for issue in integrity_report['integrity_issues'][:10]:
                            print(f"  - {issue}")
                            
            except Exception as e:
                print(f"Validation error: {e}")
                    
        elif action == 'history':
            # Property history and versioning
            operation = 'view'  # default
            property_name = None
            version = None
            version2 = None
            limit = 100
            reason = None
            
            i = 0
            while i < len(remaining):
                if remaining[i] == '--operation' and i + 1 < len(remaining):
                    operation = remaining[i + 1]
                    i += 2
                elif remaining[i] == '--property' and i + 1 < len(remaining):
                    property_name = remaining[i + 1]
                    i += 2
                elif remaining[i] == '--version' and i + 1 < len(remaining):
                    version = int(remaining[i + 1])
                    i += 2
                elif remaining[i] == '--version2' and i + 1 < len(remaining):
                    version2 = int(remaining[i + 1])
                    i += 2
                elif remaining[i] == '--limit' and i + 1 < len(remaining):
                    limit = int(remaining[i + 1])
                    i += 2
                elif remaining[i] == '--reason' and i + 1 < len(remaining):
                    reason = remaining[i + 1]
                    i += 2
                else:
                    i += 1
                    
            try:
                from mace.database.history import PropertyHistory
                history = PropertyHistory(db.db_path)
                
                if operation == 'view':
                    if not material_id:
                        print("Error: --material-id required for viewing history")
                        return
                        
                    report = history.format_history_report(material_id, property_name)
                    print(report)
                    
                elif operation == 'snapshot':
                    if not material_id:
                        print("Error: --material-id required for creating snapshot")
                        return
                        
                    version_num = history.create_material_snapshot(material_id, 'user', reason)
                    print(f"Created snapshot version {version_num} for {material_id}")
                    
                elif operation == 'compare':
                    if not material_id or not version or not version2:
                        print("Error: --material-id, --version, and --version2 required for comparison")
                        return
                        
                    comparison = history.compare_versions(material_id, version, version2)
                    
                    if 'error' in comparison:
                        print(f"Error: {comparison['error']}")
                    else:
                        print(f"\n=== Version Comparison: {material_id} ===")
                        print(f"Version {version} ({comparison['version1']['created_at']}) vs "
                              f"Version {version2} ({comparison['version2']['created_at']})")
                        print(f"\nTotal changes: {comparison['total_changes']}")
                        
                        if comparison['added']:
                            print(f"\nAdded properties ({len(comparison['added'])}):")
                            for prop in comparison['added']:
                                print(f"  + {prop['property']}: {prop['new_value']} {prop.get('new_unit', '')}")
                                
                        if comparison['removed']:
                            print(f"\nRemoved properties ({len(comparison['removed'])}):")
                            for prop in comparison['removed']:
                                print(f"  - {prop['property']}: {prop['old_value']} {prop.get('old_unit', '')}")
                                
                        if comparison['changed']:
                            print(f"\nChanged properties ({len(comparison['changed'])}):")
                            for prop in comparison['changed']:
                                print(f"  ~ {prop['property']}: {prop['old_value']} → {prop['new_value']}")
                                
                elif operation == 'rollback':
                    if not material_id or not property_name or not version or not reason:
                        print("Error: --material-id, --property, --version, and --reason required for rollback")
                        return
                        
                    success = history.rollback_property(material_id, property_name, version, reason)
                    if success:
                        print(f"Successfully rolled back {property_name} to version {version}")
                    else:
                        print("Rollback failed - version not found")
                        
                elif operation == 'recent':
                    changes = history.get_recent_changes(limit, material_id)
                    
                    print(f"\n=== Recent Property Changes ===")
                    print(f"Showing last {min(len(changes), limit)} changes")
                    
                    for change in changes:
                        print(f"\n{change['changed_at']} - {change['material_id']} ({change.get('formula', 'N/A')})")
                        print(f"  {change['property_name']}: {change['old_value']} → {change['property_value']}")
                        if change.get('change_reason'):
                            print(f"  Reason: {change['change_reason']}")
                            
                else:
                    print(f"Unknown operation: {operation}")
                    
            except Exception as e:
                print(f"History error: {e}")
                import traceback
                traceback.print_exc()
                    
        elif action == 'interactive':
            # Launch interactive explorer
            try:
                from mace.database.interactive import run_interactive_explorer
                run_interactive_explorer(db.db_path)
            except Exception as e:
                print(f"Interactive mode error: {e}")
                import traceback
                traceback.print_exc()
                    
        elif action == 'aggregate':
            # Aggregate properties by groups
            group_by = None
            properties = []
            aggregation = 'mean'
            filters = []
            detailed = False
            output_format = 'report'
            
            i = 0
            while i < len(remaining):
                if remaining[i] == '--group-by' and i + 1 < len(remaining):
                    group_by = remaining[i + 1]
                    i += 2
                elif remaining[i] == '--properties' and i + 1 < len(remaining):
                    properties = [p.strip() for p in remaining[i + 1].split(',')]
                    i += 2
                elif remaining[i] == '--aggregation' and i + 1 < len(remaining):
                    aggregation = remaining[i + 1]
                    i += 2
                elif remaining[i] == '--filter' and i + 1 < len(remaining):
                    filters.append(remaining[i + 1])
                    i += 2
                elif remaining[i] == '--detailed':
                    detailed = True
                    i += 1
                elif remaining[i] == '--output-format' and i + 1 < len(remaining):
                    output_format = remaining[i + 1]
                    i += 2
                else:
                    i += 1
                    
            if not group_by or not properties:
                print("Error: --group-by and --properties are required")
                print("Use 'mace database --action aggregate --help' for usage")
                return
                
            try:
                from mace.database.analysis import aggregate_by_groups
                result = aggregate_by_groups(
                    db, group_by, properties, aggregation,
                    filters if filters else None,
                    output_format, detailed
                )
                print(result)
            except Exception as e:
                print(f"Aggregation error: {e}")
                import traceback
                traceback.print_exc()
                    
        elif action == 'clean':
            # Clean up orphaned records
            print("Database cleanup not yet implemented")
            
    elif args.command == 'engine':
        # Workflow engine command
        from workflow.engine import main as engine_main
        # Combine all arguments
        all_args = args.args + remaining
        sys.argv = ['engine.py'] + all_args
        engine_main()
        
    elif args.command == 'version':
        # Show version with main banner
        if BANNER_AVAILABLE:
            print_banner('banner')  # Use main banner
            print(f"\n    Version: {__version__}")
            print("    CRYSTAL Support: CRYSTAL17, CRYSTAL23")
        else:
            print(f"\nMACE v{__version__}")
            print("Mendoza Automated CRYSTAL Engine")
            print("CRYSTAL Support: CRYSTAL17, CRYSTAL23")

if __name__ == "__main__":
    main()