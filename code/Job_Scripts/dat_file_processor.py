#!/usr/bin/env python3
"""
DAT File Processor for CRYSTAL Calculations
===========================================
Process BAND.DAT and DOSS.DAT files generated by CRYSTAL band structure 
and density of states calculations to extract electronic structure information.

Author: Generated for materials database project
"""

import numpy as np
import re
from pathlib import Path
from typing import Dict, List, Any, Tuple, Optional


class DatFileProcessor:
    """Process CRYSTAL .DAT files (BAND.DAT and DOSS.DAT)."""
    
    def __init__(self):
        pass
    
    def process_band_dat_file(self, file_path: Path) -> Dict[str, Any]:
        """
        Process BAND.DAT file to extract band structure information.
        
        Args:
            file_path: Path to BAND.DAT file
            
        Returns:
            Dictionary with band structure data
        """
        if not file_path.exists():
            return {"error": f"File not found: {file_path}"}
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            results = {
                'file_type': 'BAND.DAT',
                'file_path': str(file_path),
                'k_points': [],
                'eigenvalues': [],
                'band_structure_data': {},
                'electronic_properties': {}
            }
            
            # Parse the band structure data
            results.update(self._parse_band_dat_content(content))
            
            # Extract electronic properties
            results['electronic_properties'] = self._analyze_band_structure(results)
            
            return results
            
        except Exception as e:
            return {"error": f"Error processing BAND.DAT file: {e}"}
    
    def process_doss_dat_file(self, file_path: Path) -> Dict[str, Any]:
        """
        Process DOSS.DAT file to extract density of states information.
        
        Args:
            file_path: Path to DOSS.DAT file
            
        Returns:
            Dictionary with density of states data
        """
        if not file_path.exists():
            return {"error": f"File not found: {file_path}"}
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            results = {
                'file_type': 'DOSS.DAT',
                'file_path': str(file_path),
                'energy_points': [],
                'total_dos': [],
                'projected_dos': {},
                'dos_analysis': {}
            }
            
            # Parse the DOS data
            results.update(self._parse_doss_dat_content(content))
            
            # Analyze DOS
            results['dos_analysis'] = self._analyze_density_of_states(results)
            
            return results
            
        except Exception as e:
            return {"error": f"Error processing DOSS.DAT file: {e}"}
    
    def _parse_band_dat_content(self, content: str) -> Dict[str, Any]:
        """Parse BAND.DAT file content."""
        lines = content.strip().split('\n')
        
        results = {
            'num_k_points': 0,
            'num_bands': 0,
            'k_points': [],
            'eigenvalues': [],
            'k_path_labels': []
        }
        
        if not lines:
            return results
        
        # Try to parse header information
        try:
            # First line often contains dimensions
            if lines[0].strip():
                parts = lines[0].split()
                if len(parts) >= 2:
                    results['num_k_points'] = int(parts[0])
                    results['num_bands'] = int(parts[1])
        except (ValueError, IndexError):
            pass
        
        # Parse k-points and eigenvalues
        current_line = 1
        k_points = []
        eigenvalues = []
        
        while current_line < len(lines):
            line = lines[current_line].strip()
            if not line:
                current_line += 1
                continue
            
            try:
                # Try to parse as k-point followed by eigenvalues
                parts = line.split()
                if len(parts) >= 4:  # k-point (3 values) + at least one eigenvalue
                    k_point = [float(parts[0]), float(parts[1]), float(parts[2])]
                    k_points.append(k_point)
                    
                    # Eigenvalues are the remaining values
                    eigvals = [float(x) for x in parts[3:]]
                    eigenvalues.append(eigvals)
            except ValueError:
                pass
            
            current_line += 1
        
        results['k_points'] = k_points
        results['eigenvalues'] = eigenvalues
        results['num_k_points'] = len(k_points)
        if eigenvalues:
            results['num_bands'] = len(eigenvalues[0]) if eigenvalues[0] else 0
        
        return results
    
    def _parse_doss_dat_content(self, content: str) -> Dict[str, Any]:
        """Parse DOSS.DAT file content."""
        lines = content.strip().split('\n')
        
        results = {
            'num_energy_points': 0,
            'energy_range': [0, 0],
            'energy_points': [],
            'total_dos': [],
            'projected_dos': {}
        }
        
        if not lines:
            return results
        
        # Parse DOS data
        energy_points = []
        total_dos = []
        projected_dos = {}
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            try:
                parts = line.split()
                if len(parts) >= 2:
                    energy = float(parts[0])
                    total_density = float(parts[1])
                    
                    energy_points.append(energy)
                    total_dos.append(total_density)
                    
                    # Additional columns might be projected DOS
                    if len(parts) > 2:
                        for i, val in enumerate(parts[2:], start=2):
                            col_name = f'projected_dos_{i}'
                            if col_name not in projected_dos:
                                projected_dos[col_name] = []
                            projected_dos[col_name].append(float(val))
            except ValueError:
                continue
        
        results['energy_points'] = energy_points
        results['total_dos'] = total_dos
        results['projected_dos'] = projected_dos
        results['num_energy_points'] = len(energy_points)
        
        if energy_points:
            results['energy_range'] = [min(energy_points), max(energy_points)]
        
        return results
    
    def _analyze_band_structure(self, band_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze band structure data to extract electronic properties."""
        analysis = {
            'band_gap_direct': None,
            'band_gap_indirect': None,
            'valence_band_maximum': None,
            'conduction_band_minimum': None,
            'fermi_level_estimate': None,
            'metallic': False
        }
        
        eigenvalues = band_data.get('eigenvalues', [])
        if not eigenvalues:
            return analysis
        
        try:
            # Convert to numpy array for easier manipulation
            eig_array = np.array(eigenvalues)
            
            # Find band gap (assuming last occupied band is HOMO, first unoccupied is LUMO)
            # This is a simplified approach - would need more sophisticated analysis for real cases
            max_occupied = np.max(eig_array)
            min_unoccupied = np.min(eig_array[eig_array > max_occupied]) if np.any(eig_array > max_occupied) else None
            
            if min_unoccupied is not None:
                band_gap = min_unoccupied - max_occupied
                analysis['band_gap_indirect'] = band_gap
                analysis['valence_band_maximum'] = max_occupied
                analysis['conduction_band_minimum'] = min_unoccupied
                analysis['metallic'] = band_gap < 0.01  # eV threshold
            else:
                analysis['metallic'] = True
            
        except Exception:
            pass
        
        return analysis
    
    def _analyze_density_of_states(self, dos_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze density of states data."""
        analysis = {
            'fermi_level': None,
            'band_gap_from_dos': None,
            'total_states': 0,
            'peak_positions': [],
            'dos_at_fermi': 0
        }
        
        energy_points = dos_data.get('energy_points', [])
        total_dos = dos_data.get('total_dos', [])
        
        if not energy_points or not total_dos:
            return analysis
        
        try:
            energy_array = np.array(energy_points)
            dos_array = np.array(total_dos)
            
            # Estimate Fermi level (where DOS drops significantly)
            # This is a simplified approach
            max_dos = np.max(dos_array)
            threshold = max_dos * 0.1
            
            # Find band gap as region with low DOS
            low_dos_indices = dos_array < threshold
            if np.any(low_dos_indices):
                gap_energies = energy_array[low_dos_indices]
                if len(gap_energies) > 0:
                    analysis['band_gap_from_dos'] = np.max(gap_energies) - np.min(gap_energies)
            
            # Find peaks in DOS
            dos_peaks = []
            for i in range(1, len(dos_array) - 1):
                if dos_array[i] > dos_array[i-1] and dos_array[i] > dos_array[i+1]:
                    if dos_array[i] > max_dos * 0.2:  # Significant peaks only
                        dos_peaks.append(energy_array[i])
            
            analysis['peak_positions'] = dos_peaks
            analysis['total_states'] = np.trapz(dos_array, energy_array)
            
        except Exception:
            pass
        
        return analysis


def process_calculation_dat_files(calc_id: str, work_dir: str, db_path: str = "materials.db") -> Dict[str, Any]:
    """
    Process all DAT files for a specific calculation.
    
    Args:
        calc_id: Calculation ID
        work_dir: Working directory containing DAT files
        db_path: Path to materials database
        
    Returns:
        Dictionary with processed DAT file data
    """
    from material_database import MaterialDatabase
    
    processor = DatFileProcessor()
    results = {}
    
    work_path = Path(work_dir)
    
    # Look for BAND.DAT files
    band_dat_files = list(work_path.glob("*BAND.DAT")) + list(work_path.glob("*band.dat"))
    for band_file in band_dat_files:
        results[f'band_structure_{band_file.stem}'] = processor.process_band_dat_file(band_file)
    
    # Look for DOSS.DAT files  
    doss_dat_files = list(work_path.glob("*DOSS.DAT")) + list(work_path.glob("*doss.dat"))
    for doss_file in doss_dat_files:
        results[f'density_of_states_{doss_file.stem}'] = processor.process_doss_dat_file(doss_file)
    
    # Save results to database if files were found
    if results:
        db = MaterialDatabase(db_path)
        
        for file_type, data in results.items():
            if 'error' not in data:
                # Save as a property in the database
                property_name = f"dat_file_{file_type}"
                
                try:
                    with db._get_connection() as conn:
                        # Get material_id for this calc_id
                        cursor = conn.execute("SELECT material_id FROM calculations WHERE calc_id = ?", (calc_id,))
                        material_row = cursor.fetchone()
                        if material_row:
                            material_id = material_row[0]
                            
                            # Insert the DAT file data as a property
                            conn.execute("""
                                INSERT OR REPLACE INTO properties 
                                (material_id, calc_id, property_category, property_name, 
                                 property_value_text, property_unit, extracted_at, extractor_script)
                                VALUES (?, ?, ?, ?, ?, ?, datetime('now'), ?)
                            """, (material_id, calc_id, 'electronic', property_name,
                                  str(data), 'N/A', 'dat_file_processor.py'))
                except Exception as e:
                    print(f"Error saving DAT file data for {calc_id}: {e}")
    
    return results


if __name__ == "__main__":
    # Test DAT file processing
    print("🧪 Testing DAT File Processing:")
    print("=" * 40)
    
    # Look for DAT files in workflow outputs
    from pathlib import Path
    
    workflow_dir = Path("workflow_outputs")
    
    # Find any DAT files
    dat_files = list(workflow_dir.rglob("*.DAT")) + list(workflow_dir.rglob("*.dat"))
    
    if dat_files:
        print(f"Found {len(dat_files)} DAT files:")
        for dat_file in dat_files:
            print(f"  {dat_file}")
        
        # Test processing the first one
        processor = DatFileProcessor()
        test_file = dat_files[0]
        
        if "band" in test_file.name.lower():
            result = processor.process_band_dat_file(test_file)
            print(f"\nBand structure analysis of {test_file.name}:")
            print(f"  K-points: {result.get('num_k_points', 0)}")
            print(f"  Bands: {result.get('num_bands', 0)}")
            if 'electronic_properties' in result:
                props = result['electronic_properties']
                print(f"  Band gap: {props.get('band_gap_indirect', 'N/A')} eV")
                print(f"  Metallic: {props.get('metallic', 'Unknown')}")
        
        elif "doss" in test_file.name.lower():
            result = processor.process_doss_dat_file(test_file)
            print(f"\nDOS analysis of {test_file.name}:")
            print(f"  Energy points: {result.get('num_energy_points', 0)}")
            print(f"  Energy range: {result.get('energy_range', 'N/A')}")
            if 'dos_analysis' in result:
                analysis = result['dos_analysis']
                print(f"  Total states: {analysis.get('total_states', 'N/A')}")
                print(f"  Peak positions: {analysis.get('peak_positions', 'N/A')}")
    else:
        print("No DAT files found in workflow outputs")